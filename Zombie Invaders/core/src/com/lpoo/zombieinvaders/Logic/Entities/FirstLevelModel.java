package com.lpoo.zombieinvaders.Logic.Entities;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.lpoo.zombieinvaders.GUI.Screens.EndScreen;
import com.lpoo.zombieinvaders.Tools.ShapeCollision;
import com.lpoo.zombieinvaders.ZombieInvaders;

import java.util.ArrayList;
import java.util.Random;

/**
 * Created by bernardoleite on 28/05/17.
 */

public class FirstLevelModel {

    CharacterModel person;

    public boolean thebool = false;

    public static final float TESTING_VELOCITY = 3f;

    public static  float ZOMBIE_TIMER_SPAWN_MIN = 0.3f;
    public static  float ZOMBIE_TIMER_SPAWN_MAX = 0.6f;

    public static final float BANANAS_TIMER_SPAWN_MIN = 0.3f;
    public static final float BANANAS_TIMER_SPAWN_MAX = 10f;

    public static final float MORANGOS_TIMER_SPAWN_MIN = 0.1f;
    public static final float MORANGOS_TIMER_SPAWN_MAX = 13f;

    public  boolean zombie_bullet = false;
    public  boolean morango_person = false;

    private Music music;

    float stateTime;
    float timerBetweenZombieSpawn;
    float timerBetweenBananasSpawn;
    float timerBetweenMorangosSpawn;

    Random random;
    ZombieInvaders game;
    GameModel model;

    ArrayList<BulletModel> bullets;
    ArrayList<ZombieModel> zombies;
    ArrayList<ExplosionModel> explosions;
    ArrayList<BananasModel> bananas;
    ArrayList<MorangoModel> morangos;

    ShapeCollision healthBar;

    int thescore;
    int nrbananas = 20;

    //0 sem vida , 1 com vida cheia
    int health = 100;

    /** This method is the constructor that creates the level
     *
     * @param game is the main object from the Class generated by LibGdx
     * @param model is the object from the Controller Class
     */
    public FirstLevelModel(ZombieInvaders game, GameModel model){

        person = new CharacterModel();

        this.model = model;
        this.game = game;


        bullets = new ArrayList<BulletModel>();
        zombies = new ArrayList<ZombieModel>();
        explosions = new ArrayList<ExplosionModel>();
        bananas = new ArrayList<BananasModel>();
        morangos = new ArrayList<MorangoModel>();

        healthBar = new ShapeCollision(0, 0, person.PERSON_WIDTH, person.PERSON_HEIGHT );

        thescore = 0;

        random = new Random();
        timerBetweenZombieSpawn = random.nextFloat() * (ZOMBIE_TIMER_SPAWN_MAX - ZOMBIE_TIMER_SPAWN_MIN) + ZOMBIE_TIMER_SPAWN_MIN;
        timerBetweenBananasSpawn = random.nextFloat() * (BANANAS_TIMER_SPAWN_MAX - BANANAS_TIMER_SPAWN_MIN) + BANANAS_TIMER_SPAWN_MIN;
        timerBetweenMorangosSpawn = random.nextFloat() * (MORANGOS_TIMER_SPAWN_MAX - MORANGOS_TIMER_SPAWN_MIN) + MORANGOS_TIMER_SPAWN_MIN;



    }

    /** This method has the responsability to control de bullets
     *
     * @param delta is a value that is constantly being updated
     */
    public void shootingCode(float delta){


        //Shooting code
        person.shootTimer += delta;
        if (model.isShooting() && person.shootTimer >= person.SHOOT_WAIT_TIME && nrbananas >= 1) {
            person.shootTimer = 0;

            nrbananas--;

            bullets.add(new BulletModel(person.getxposition()  ));


        }

    }

    /** This method has the responsability to spawn randomly the zombies on Game
     *
     * @param delta is a value of time that is constanty being updated
     */
    public void spawnZombies(float delta){

        //Spawn Zombies
        timerBetweenZombieSpawn -= delta;
        if  (timerBetweenZombieSpawn <= 0) {
            timerBetweenZombieSpawn = random.nextFloat() * (ZOMBIE_TIMER_SPAWN_MAX - ZOMBIE_TIMER_SPAWN_MIN) + ZOMBIE_TIMER_SPAWN_MIN;
            zombies.add(new ZombieModel(random.nextInt(ZombieInvaders.WIDTH - ZombieModel.WIDTH)));
        }

    }

    /**This method has the responsability to spawn randomly the Bananas on Game
     *
     * @param delta is a value of time that is constanty being updated
     */
    public void spawnBananas(float delta){
        //Spawn Bananas
        timerBetweenBananasSpawn -= delta;
        if  (timerBetweenBananasSpawn <= 0) {
            timerBetweenBananasSpawn = random.nextFloat() * (BANANAS_TIMER_SPAWN_MAX - BANANAS_TIMER_SPAWN_MIN) + BANANAS_TIMER_SPAWN_MIN;
            bananas.add(new BananasModel(random.nextInt(ZombieInvaders.WIDTH - ZombieModel.WIDTH)));
        }

    }

    /** This method has the responsability to spawn randomly the Morangos on Game
     *
     * @param delta is a value of time that is constanty being updated
     */
    public void spawnMorangos(float delta){
        //Spawn Moranos
        timerBetweenMorangosSpawn -= delta;
        if  (timerBetweenMorangosSpawn <= 0) {
            timerBetweenMorangosSpawn = random.nextFloat() * (MORANGOS_TIMER_SPAWN_MAX - MORANGOS_TIMER_SPAWN_MIN) + MORANGOS_TIMER_SPAWN_MIN;
            morangos.add(new MorangoModel(random.nextInt(ZombieInvaders.WIDTH - ZombieModel.WIDTH)));
        }

    }


    ArrayList<MorangoModel> morangosToRemove = new ArrayList<MorangoModel>();

    /**
     * This method has the responsability to spawn update the Morangos on Game
     * @param delta is a value of time that is constanty being updated
     */
    public void updateMorangos(float delta){
        //Update Morangos
        for (MorangoModel morango: morangos) {
            morango.update(delta);

        }
    }

    ArrayList<BananasModel> bananasToRemove = new ArrayList<BananasModel>();
    /**
     * This method has the responsability to spawn update the Bananas on Game
     * @param delta is a value of time that is constanty being updated
     */
    public void updateBananas(float delta){
        //Update Bananas
        for (BananasModel banana: bananas) {
            banana.update(delta);

        }
    }


    ArrayList<ZombieModel> zombiesToRemove = new ArrayList<ZombieModel>();
    /**
     * This method has the responsability to spawn update Zombies on Game
     * @param delta is a value of time that is constanty being updated
     */
    public void updateZombies(float delta){

        //Update Zombies

        for (ZombieModel zombie: zombies) {
            zombie.update(delta);
            if(zombie.remove)
                zombiesToRemove.add(zombie);

        }
    }


    ArrayList<BulletModel> bulletsToRemove = new ArrayList<BulletModel>();
    /**
     * This method has the responsability to spawn update Bullets on Game
     * @param delta is a value of time that is constanty being updated
     */
    public void updateBullets(float delta){
        //Update bullets


        for (BulletModel bullet : bullets) {
            bullet.update(delta);
            if (bullet.remove)
                bulletsToRemove.add(bullet);
        }
    }
    /**
     * This method has the responsability to spawn update Explosions on Game
     * @param delta is a value of time that is constanty being updated
     */
    public void updateExplosions(float delta){

        //Atualizar as explosões
        ArrayList<ExplosionModel> explosionToRemove = new ArrayList<ExplosionModel>();
        for (ExplosionModel explosion: explosions){
            explosion.update(delta);
            if (explosion.remove)
                explosionToRemove.add(explosion);
        }
        explosions.removeAll(explosionToRemove);
    }
    /**
     * This method deals with the movement to the left
     * @param delta is a value of time that is constanty being updated
     */
    public void treatLeftMovement(float delta){

        if (model.isLeft()) {

            if(thebool)
            {
                person.x -= TESTING_VELOCITY;
            }
            else person.x -= person.SPEED * Gdx.graphics.getDeltaTime() ;

            if (person.x < 0)
                 person.x = 0;
        }

    }
    /**
     * This method deals with the movement to the right
     * @param delta is a value of time that is constanty being updated
     */
    public void treatRightMovement(float delta) {

        if (model.isRight() ) {
            if(thebool)
            {
                person.x += TESTING_VELOCITY;
            }
            else person.x += person.SPEED * Gdx.graphics.getDeltaTime() ;

            if (person.x + person.PERSON_WIDTH > ZombieInvaders.WIDTH)
                person.x = ZombieInvaders.WIDTH - person.PERSON_WIDTH;

        }

    }

    /**
     * This method deals with the collisions between objects
     * @param delta is a value of time that is constanty being updated
     */
    public void verifyCollisions(float delta){
        //Verificar Colisões
        for (BulletModel bullet: bullets){
            for (ZombieModel zombie: zombies){
                if (bullet.getShapeCollision().checkCollision(zombie.getCollisionRect())){
                    zombie_bullet = true;
                    bulletsToRemove.add(bullet);
                    zombiesToRemove.add(zombie);
                    explosions.add(new ExplosionModel(zombie.getXposition(), zombie.getYposition()));
                    thescore+=1;

                    if(thescore % 10 == 0) {
                       if(ZOMBIE_TIMER_SPAWN_MIN >= 0.03) ZOMBIE_TIMER_SPAWN_MIN -= 0.03;
                       if( ZOMBIE_TIMER_SPAWN_MAX >= 0.03) ZOMBIE_TIMER_SPAWN_MAX -= 0.03;
                    }
                }
            }
        }

        zombies.removeAll(zombiesToRemove);
        bullets.removeAll(bulletsToRemove);

        for( ZombieModel zombie: zombies){
            if (zombie.getCollisionRect().checkCollision(healthBar)){
                zombiesToRemove.add(zombie);
                health -= 10;

                //Verificar a vida
                if(health <= 0){
                     ZOMBIE_TIMER_SPAWN_MIN = 0.3f;
                     ZOMBIE_TIMER_SPAWN_MAX = 0.6f;
                    game.setScreen(new EndScreen(game, thescore));
                }
            }
        }

        for( BananasModel banana: bananas){
            if (banana.getCollisionRect().checkCollision(healthBar)){
                bananasToRemove.add(banana);
                nrbananas += 20;

            }
        }


        for( MorangoModel morango: morangos){
            if (morango.getCollisionRect().checkCollision(healthBar)){
                morango_person = true;
                morangosToRemove.add(morango);
                if(health <= 90)
                     health += 10;

            }
        }

        morangos.removeAll(morangosToRemove);
        bananas.removeAll(bananasToRemove);
        zombies.removeAll(zombiesToRemove);

    }

    /**
     * This method is constantly updating the game
     * @param delta is a value of time that is constanty being updated
     */
    public void render (float delta) {

        if(thebool == false){
            music = ZombieInvaders.manager.get("arcade.ogg", Music.class);
            music.setLooping(true);
            music.play();}


        shootingCode(delta);

        spawnZombies(delta);

        spawnBananas(delta);

        spawnMorangos(delta);

        updateZombies(delta);

        updateBananas(delta);

        updateMorangos(delta);

        updateBullets(delta);

        updateExplosions(delta);

        treatLeftMovement(delta);

        treatRightMovement(delta);

        //Depois do movimento do jogador, atualizar collisao
        healthBar.move(person.x,person.y);

        verifyCollisions(delta);

        stateTime += delta;


    }
    /**
     *
     * @return the state time
     */
    public float getStateTime(){
        return stateTime;
    }

    /**
     *
     * @return an array of bullets of the main game
     */
    public ArrayList<BulletModel> getBullets(){return bullets;}

    /**
     *
     * @return an array of bananas of the main game
     */
    public ArrayList<BananasModel> getBananas(){return bananas;}

    /**
     *
     * @return an array of morangos of the main game
     */
    public ArrayList<MorangoModel> getMorangos(){return morangos;}

    /**
     *
     * @return an array of zombies of the main game
     */
    public ArrayList<ZombieModel> getZombies(){
        return zombies;
    }

    /**
     *
     * @return an array of explosions of the main game
     */
    public ArrayList<ExplosionModel> getExplosions(){
        return explosions;
    }

    /**
     *
     * @return the value of zombies killed
     */
    public int getThescore(){
        return thescore;
    }

    /**
     *
     * @return the nr of bananas catched by the player
     */
    public int getThenrbananas(){
        return nrbananas;
    }

    /**
     *
     * @return the value of current health
     */
    public int getHealth(){
        return health;
    }


    /**
     *
     * @return position of person
     */
    public float getx(){
        return person.x;
    }

    /**
     *
     * @return position of person
     */
    public float gety(){
        return person.y;
    }

}
